"""
В Берляндии есть проспект Берленина, по которому ходит автобус.
Проспект можно считать прямой, вдоль которой введена система координат.
Всего на проспекте есть n остановок,
i-я из которых находится в точке с координатой ai.
Паша пишет новое приложение для отслеживания автобусов и хочет рисовать
иконку автобуса около ближайшей остановки.
Формально, если автобус имеет координату x, то выбирается номер остановки
i, минимизирующий ∣ai–x∣. Если таких i несколько, то Паша выбирает
номер нужно остановки по очень странным правилам:
-Если есть остановки, совпадающие с координатой автобуса,
то стоит вывести минимальную по номеру среди них.
-Если есть остановки справа и слева, то стоит вывести максимальную
по номеру среди левых.
-Если есть остановки только слева, то стоит вывести максимальную
по номеру среди левых.
-Если есть остановки только справа, то стоит вывести минимальную
по номеру среди правых.

Пашино приложение ещё не готово до конца, поэтому он просит вас помочь
разработать эту функциональность. Для теста он выдал вам
k запросов, каждый из которых задаётся числом
x — координатой автобуса.

Формат ввода
В первой строке входных данных содержатся числа
n и k (1≤n,k≤10**5) — количество остановок и запросов соответственно.
Во второй строке задаётся n целых чисел, отсортированных по неубыванию, —ai,
а в третьей строке — k запросов,
каждый из которых составляет координату автобуса.
Каждое число находится в промежутке [–2⋅10**9; 2⋅10**9]

Формат вывода
Для каждого запроса выведите номер ближайшей к автобусу остановки
(1 ≤ i ≤ n). Если таких номеров несколько, выведите минимальный из них.

Примечание
В примере даны остановки с координатами
1,3,5.

Для первого запроса автобус находится в точке 4 и расстояния
до остановок от него равны 3, 1 и 1 соответственно.
Это значит, что существуют оптимальные остановки слева (остановка с номером 2)
и справа (остановка с номером 3),
а значит нужно выбрать максимальную по номеру среди левых - 2.

Во время второго запроса автобус находится в точке 1, а значит существует
всего одна остановка, минимизирующая заданное расстояние.

Ограничения
Ограничение времени 1 с

Ограничение памяти 256 МБ

Пример 1
Ввод
3 2
1 3 5
4 1

Вывод
2
1
"""
from bisect import bisect_left


def load_data():
    n, k = map(int, input().split())
    stops = list(map(int, input().split()))
    queries = list(map(int, input().split()))
    return n, k, stops, queries


def find_nearest_stop(stops: list | tuple, query: int) -> int:
    left = 0
    right = len(stops) - 1

    while left <= right:

        mid = (left + right) // 2
        if stops[mid] < query:
            left = mid + 1
        elif stops[mid] > query:
            right = mid - 1
        else:
            if stops[mid - 1] == query:
                right = mid - 1
            else:
                return mid + 1

    if left >= len(stops):
        return len(stops)
    if right < 0:
        return 1

    diff_left = abs(stops[left] - query)
    diff_right = abs(stops[right] - query)

    if diff_left < diff_right:
        return left + 1
    else:
        return right + 1


def find_closest(nums: list[int], k: int) -> int:
    i = bisect_left(nums, k)
    if i >= len(nums):
        return len(nums)
    if i == 0:
        return 1
    if k - nums[i - 1] == nums[i] - k:
        return i
    if k - nums[i - 1] < nums[i] - k:
        return i - 1
    else:
        return i + 1


def main():
    # n, k, stops, queries = load_data()
    # for query in queries:
    #     res = find_nearest_stop3(stops, query)
    #     print(res)

    assert find_nearest_stop((1, 3, 5, 5, 6), 5) == 3
    assert find_nearest_stop((1, 3, 5, 5, 6), 1) == 1
    assert find_nearest_stop((1, 3, 5, 5, 6), 4) == 2
    assert find_nearest_stop((1, 3, 3, 5, 5, 6), 3) == 2
    assert find_nearest_stop((1, 3, 3, 10, 10, 12), 8) == 4
    assert find_nearest_stop((1, 1, 1, 2), 1) == 1
    assert find_nearest_stop(((1,) * 100000), 2) == 100000
    assert find_nearest_stop((2, 2, 2, 2), 1) == 1

    assert find_closest([1, 3, 5, 5, 6], 5) == 3
    assert find_closest([1, 3, 5, 5, 6], 1) == 1
    assert find_closest([1, 3, 5, 5, 6], 4) == 2
    assert find_closest([1, 3, 3, 5, 5, 6], 3) == 2
    assert find_closest([1, 3, 3, 10, 10, 12], 8) == 4
    assert find_closest([1, 1, 1, 2], 1) == 1
    assert find_closest(([1, ] * 100000), 2) == 100000
    assert find_closest([2, 2, 2, 2], 1) == 1


if __name__ == '__main__':
    main()
